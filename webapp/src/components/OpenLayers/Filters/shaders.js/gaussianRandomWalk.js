// Code Generated by chatGPT
// Main program
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl2');

// Set the viewport size
gl.viewport(0, 0, canvas.width, canvas.height);

// Create the vertex data for a single point
const vertices = new Float32Array([0, 0, 0, 1]);

// Create a vertex buffer object to store the vertex data
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

// Create the vertex shader
const vertexShaderSource = `#version 300 es
in vec4 a_position;

uniform float u_time;

void main() {
  // Generate a random number with a Gaussian distribution
  float rand = randn(u_time);

  // Update the position of the vertex using the random number
  gl_Position = a_position + vec4(rand, rand, 0, 0);
}`;

const vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, vertexShaderSource);
gl.compileShader(vertexShader);

// Create the fragment shader
const fragmentShaderSource = `#version 300 es
precision mediump float;

out vec4 outColor;

void main() {
  // Set the fragment color to white
  outColor = vec4(1, 1, 1, 1);
}`;

const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, fragmentShaderSource);
gl.compileShader(fragmentShader);

// Create the program
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// Bind the vertex data to the program
const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionAttributeLocation);

const size = 2;          // 2 components per iteration
const type = gl.FLOAT;   // the data is 32bit floats
const normalize = false; // don't normalize the data
const stride = 0;       
